# 요구사항
표를 검사하고 극장에 입장시키는 시스템
- 표가 있어야만 극장에 입장할 수 있다
- 표는 구매할 수 있다
- 초대장이 있다면 추가요금 없이 표로 바꿀 수 있다
- 고객은 초대장이 있거나 없을 수 있다

# 이번장에서 익혀야 할 주요개념
- 요구사항에서 `도메인, 각 도메인이 가져야 할 데이터, 주고받아야 할 메시지` 를 추출한다 
- 높은 응집도 : 특정 목적을 위한 데이터와 기능이 밀접하게 모여있을 경우 응집도가 높다고 말한다
- 낮은 결합도 : 하나의 객체가 의존하는 객체에 대해 너무 많이 알고있으면 안된다
  - 클래스 다이어그램을 그렸을 때 선이 2depth 이상을 넘어가는 것이 있다면 제거해주는 것이 좋다
  - TicketSeller -> TicketOffice -> Ticket 의 의존인데 TicketSeller --> Ticket 으로도 의존이 되고 있을 경우 제거해주는 것이 좋다
- 캡슐화 : 객체는 사용하는 `데이터`나 구체적인 `구현`은 감추고 필요한 인터페이스만 외부에 공개
  - 외부로 자신의 데이터를 드러내어 다른 객체에서 컨트롤 가능하게 해서는 안된다
- 데이터(Data)와 처리(Process)가 한 모듈내에 존재하며, 자신의 데이터는 자신이 직접 처리해야 한다
  - 절차형 프로그래밍에서는 `프로세스` 클래스에서 `데이터` 클래스를 들고와서 로직을 처리하며, 이는 `프로세스` 클래스의 로직 중복을 야기한다
- 객체지향의 핵심은 객체를 캡술화하고 객체간에 `오직 메시지를 통해서만 상호작용하도록(객체간의 의사소통, 객체들간 공동체를 형성하여 문제를 해결)` 만드는 것이다
- 디미터의 법칙(Tell, Don't ask) : 의존관계에 있는 클래스의 필드를 직접 가져와서 수정하지 말고 직접 처리하게끔 해야한다
- 객체의 초기화는 한번에 이루어져야 한다
  - 객체가 불완전한 상태로 존재하는 구간이 있어서는 안된다
- 이해 가능한 코드란 코드의 동작이 우리 예상에서 크게 벗어나지 않고 직관적인 코드를 말한다
- 의존성은 변경에 대한 영향을 암시한다
- 객체의 의인화 : 현실세계에서는 수동적인 존재라도 객체지향의 세계에 들어오면 모든것이 능동적이고 자율적인 존재로 바뀜
- 프로그램은 오늘 잘 동작해야하며, 내일 쉽게 변경 가능해야한다(요구사항은 항상 변하기 떄문이다)

# 1차 
진행해볼 방식
- 요구사항을 분석해서 클래스를 도출한다
- 클래스간 의존관계를 전부 정의해본다
  - CRC 카드 정도로 클래스 다이어그램을 그려본다
- 코딩한다
  - 애매한 부분은 마킹정도만 해두고, 넘기고 빠르게 코딩한다
  - 애매한 부분을 고민할때 시간이 굉장히 많이 들어가기 때문이다
  - 이 부분을 왜 뒤에 고민하냐면, 코딩 중간에 고민하면 진도가 너무 안나가버리기 때문이고, 심리적으로 초조해지기 때문이다
  - 게다가 한군데 너무 시간을 많이 쏟다보면 전체적인 흐름을 보는 시간이 부족해지기 떄문이다
  - 또한 한군데 너무 집중한 클래스가 모든걸 다 보완한다고 볼 수 없다. 시작부터 완벽할수는 없기 때문이고, 전체적인 흐름에 대한 이해도 현재 부족한 상태이기 때문이다
- 다시 클래스 다이어그램을 그려본다
- 잘못된 의존관계를 처리한다
- 기존에 마킹해놨던 부분을 처리한다

의문
- 표를 얻고, 표를 쓴다 의 2step 으로 가는건 맞는 행위인가? 이상하지 않은가? 이상하다면 어디가 이상한가?
- Optional 을 필드에 쓰는건 맞는행위인가? 언제 Optional을 필드에 써야할까?
- 파라미터로 전달한 오브젝트의 상태를 바꾸는건 좋은 행위인가 나쁜 행위인가?
  - 값을 직접 바꾸지 않고 메서드를 호출해서 바꾸는건 괜찮지 않을까?
- 애초에 이렇게 까지 하드하게 룰을 짤 필요가 있을까? 간단한 법칙들만 지키면 되지 않을까?
- 왜 어려울까?
  - 문서화된 룰을 만들고 싶지 않기 때문
  - 객체의 생성자, 메서드들만 보고도 객체가 무엇을 하는 애인지 알게 하기 위함
  - 객체에서 제공하는 인터페이스가 객체의 데이터를 제한적으로 컨트롤하게 하기 위함