# 요구사항
표를 검사하고 극장에 입장시키는 시스템
- 표가 있어야만 극장에 입장할 수 있다
- 표는 구매할 수 있다
- 초대장이 있다면 추가요금 없이 표로 바꿀 수 있다
- 고객은 초대장이 있거나 없을 수 있다

# 이번장에서 익혀야 할 주요개념
- 객체들의 클래스 다이어그램을 그려서 관계를 확인한다(개발전후 모두)
  - 다이어그램을 확인하고 불필요한 관계를 끊어내야한다
  - 어떤 관계가 되도록 만들어야 할까?
- 객체가 초기화는 한번에 이루어져야 한다
  - 객체가 불완전한 상태로 존재하는 구간이 있어서는 안된다
- 코드의 동작이 우리 예상에서 크게 벗어나지 않아야한다(직관적이어야 한다)
	- 절차형 프로그래밍은 직관적이지 않다
- 응집도를 높이고, 결합도를 낮춰야 한다
	- 한 객체가 다른 객체에 대해 너무 많이 알고 있으면 결합도가 강하다고 할 수 있다
	- 결합도가 강할 경우 한 객체의 변경이 다른 객체에도 영향을 미칠 가능성이 높다 == 변화에 유연하지 못하다
	- 자신과 밀접하게 연관된 작업만을 수행할 경우 응집도가 높다고 할 수 있다
- 의존관계에 있는 클래스의 필드를 직접 가져와서 수정하지 말고 직접 처리하게끔 해야한다
- 캡슐화 : 사용하는 `데이터`나 구체적인 `구현`은 감추고 인터페이스만 외부에 공개하는 것
	- 다른 객체는 이 인터페이스에만 의존해야 한다
- 객체는 자신의 데이터와 그를 처리하는 프로세스를 같이 가져야한다(자신의 일을 스스로 처리해야함)
	- 외부로 자신의 데이터를 드러내어 다른 객체에서 컨트롤 가능하게 해서는 안된다
- 절차형 프로그래밍에서는 `프로세스` 클래스에서 `데이터` 클래스를 들고와서 로직을 처리한다
	- 데이터 클래스의 변경이 프로세스 클래스의 변경을 야기한다
	- 프로세스 클래스들의 로직 중복을 야기한다
- 객체지향의 핵심은 객체를 캡술화하고 객체간에 `오직 메시지를 통해서만 상호작용하도록` 만드는 것이다
    - 객체들끼리 공동체를 형성하여 하나의 기능을 완성한다
	- 상호작용시 의존성이 발생하는데, 이 의존성을 적절하게 조절할 수 있어야한다(인터페이스를 이용한 커뮤니케이션?)
- 하나의 기능을 완성하는데 필요한 책임이 여러 객체에 분산되어 있어야 한다
- 현실세계에서는 수동적인 존재라도 객체지향의 세계에 들어오면 모든것이 능동적이고 자율적인 존재로 바뀐다
- 프로그램은 오늘 잘 동작해야하며, 내일 쉽게 변경 가능해야한다
    - 요구사항은 항상 변하기 떄문이다

# 1차 
진행해볼 방식
- 요구사항을 분석해서 클래스를 도출한다
- 클래스간 의존관계를 전부 정의해본다
  - CRC 카드 정도로 클래스 다이어그램을 그려본다
- 코딩한다
  - 애매한 부분은 마킹정도만 해두고, 넘기고 빠르게 코딩한다
  - 애매한 부분을 고민할때 시간이 굉장히 많이 들어가기 때문이다
  - 이 부분을 왜 뒤에 고민하냐면, 코딩 중간에 고민하면 진도가 너무 안나가버리기 때문이고, 심리적으로 초조해지기 때문이다
- 다시 클래스 다이어그램을 그려본다
- 잘못된 의존관계를 처리한다
- 기존에 마킹해놨던 부분을 처리한다

의문
- 표를 얻고, 표를 쓴다 의 2step 으로 가는건 맞는 행위인가? 이상하지 않은가? 이상하다면 어디가 이상한가?
- Optional 을 필드에 쓰는건 맞는행위인가? 언제 Optional을 필드에 써야할까?